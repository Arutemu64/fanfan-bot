"""real_position

Revision ID: 002
Revises: 001
Create Date: 2023-09-23 14:11:35.321557

"""
from alembic import op
import sqlalchemy as sa
from alembic_utils.pg_function import PGFunction
from sqlalchemy import text as sql_text
from alembic_utils.pg_trigger import PGTrigger
from sqlalchemy import text as sql_text

# revision identifiers, used by Alembic.
revision = '002'
down_revision = '001'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    public_update_real_position = PGFunction(
        schema="public",
        signature="update_real_position()",
        definition='RETURNS trigger\n     LANGUAGE plpgsql\n    AS $function$\n        begin\n            with sq as (\n                select\n                    id,\n                    case when schedule.skip = false then\n                        row_number() over (partition by schedule.skip order by schedule.position)\n                    else\n                        null\n                    end as rn\n                from schedule\n            )\n            update schedule\n            set real_position = sq.rn\n            from sq\n            where schedule.id = sq.id;\n            return null;\n        END;\n    $function$'
    )
    op.create_entity(public_update_real_position)

    public_schedule_update_real_position_trigger = PGTrigger(
        schema="public",
        signature="update_real_position_trigger",
        on_entity="public.schedule",
        is_constraint=False,
        definition='after insert or delete or update of skip, "position" \n        on public.schedule for each statement execute function update_real_position()'
    )
    op.create_entity(public_schedule_update_real_position_trigger)

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    public_schedule_update_real_position_trigger = PGTrigger(
        schema="public",
        signature="update_real_position_trigger",
        on_entity="public.schedule",
        is_constraint=False,
        definition='after insert or delete or update of skip, "position" \n        on public.schedule for each statement execute function update_real_position()'
    )
    op.drop_entity(public_schedule_update_real_position_trigger)

    public_update_real_position = PGFunction(
        schema="public",
        signature="update_real_position()",
        definition='RETURNS trigger\n     LANGUAGE plpgsql\n    AS $function$\n        begin\n            with sq as (\n                select\n                    id,\n                    case when schedule.skip = false then\n                        row_number() over (partition by schedule.skip order by schedule.position)\n                    else\n                        null\n                    end as rn\n                from schedule\n            )\n            update schedule\n            set real_position = sq.rn\n            from sq\n            where schedule.id = sq.id;\n            return null;\n        END;\n    $function$'
    )
    op.drop_entity(public_update_real_position)

    # ### end Alembic commands ###
